// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19; // 使用0.8.19或更高版本，但不是0.9.0或更高版本。确保兼容性并避免未来版本的中断性更改

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MockWeatherOracle is AggregatorV3Interface, Ownable { // 继承AggregatorV3Interface和Ownable
    uint8 private _decimals;                                   // _decimals: 定义数据的精度
    string private _description;                               // _description: 可读，Feed的文字标签
    uint80 private _roundId;                                   // _roundId: 用于模拟不同的数据更新周期，从第一轮开始
    uint256 private _timestamp;                                // _timestamp: 储存当前时间
    uint256 private _lastUpdateBlock;                          // _lastUpdateBlock: 储存当前区块
 
    constructor() Ownable(msg.sender) {
        _decimals = 0; // Rainfall in whole millimeters
        _description = "MOCK/RAINFALL/USD";
        _roundId = 1;
        _timestamp = block.timestamp;
        _lastUpdateBlock = block.number;
    }

    // 预期的小数位数,我们返回0
    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    // 提供人类可读的源描述
    function description() external view override returns (string memory) {
        return _description;
    }

    // 模拟的版本1
    function version() external pure override returns (uint256) {
        return 1;
    }

    function getRoundData(uint80 _roundId_)
        external
        view
        override
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
        return (_roundId_, _rainfall(), _timestamp, _timestamp, _roundId_);
    }

    function latestRoundData()
        external
        view
        override
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
        return (_roundId, _rainfall(), _timestamp, _timestamp, _roundId);
    }

    // 模拟降雨发生器
    function _rainfall() public view returns (int256) {
        // Use block information to generate pseudo-random variation
        uint256 blocksSinceLastUpdate = block.number - _lastUpdateBlock;
        uint256 randomFactor = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.coinbase,
            blocksSinceLastUpdate
        ))) % 1000; // Random number between 0 and 999

        // Return random rainfall between 0 and 999mm
        return int256(randomFactor);
    }

    // Function to update random rainfall
    function _updateRandomRainfall() private {
        _roundId++;
        _timestamp = block.timestamp;
        _lastUpdateBlock = block.number;
    }

    // Function to force update rainfall (anyone can call)
    function updateRandomRainfall() external {
        _updateRandomRainfall();
    }
}