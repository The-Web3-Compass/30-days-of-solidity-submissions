//SPDX-License-Identifier:MIT
pragma solidity ^0.8.2;

// "import" statement brings the codes from ScientificCalculator.sol into this file which allows the Caculator contract to use functions from the other contract.
// "./" tells that this file and other files import from this statement are in the same folder.
import"./Day9ScientificCalculator.sol";

contract Calculator{
    address public owner;
    address public scientificCalculatorAddress;// Address of the already-deployed ScientificCalculator contract.

    // Solidity can not deal with decimal data. Decimal data cannot keep consistent which probably has risks of data overflow and tiny data error in every distributed node and takes large amount of gas fee in blockchain.
    constructor(){
        owner=msg.sender;
    }

    modifier onlyOwner(){
        require(msg.sender==owner,"Only owner can do this action");
        _;
    }
    
    // Once the ScientificCalculator contract is deployed, user can copy its address and pass it here.
    function setScientificCalculator(address _address) public onlyOwner{
        scientificCalculatorAddress=_address;
    }

    function add(uint256 a,uint256 b) public pure returns(uint256){
        uint256 result=a+b;
        return result;
    }

    function substract(uint256 a,uint256 b) public pure returns(uint256){
        uint256 result=a-b;
        return result;
    }

    function multiply(uint256 a,uint256 b) public pure returns(uint256){
        uint256 result=a*b;
        return result;
    }

    function divide(uint256 a,uint256 b)public pure returns(uint256){
        require(b!=0,"Cannot divide by zero");
        uint256 result=a/b;
        return result;
    }

    function calculatePower(uint256 base,uint256 exponent) public view returns(uint256){
        // Take the contract address "scientificCalculatorAddress" and cast it to a usable contract object,decalred it as "scientificCalc".
        // contract address=>contract object
        ScientificCalculator scientificCalc=ScientificCalculator(scientificCalculatorAddress);

        //external call
        // Executing power function in scientificCalc contract.
        uint256 result=scientificCalc.power(base,exponent);
        return result;
    }

    function calculatorSquareRoot(uint256 number) public returns(uint256){
        require(number>=0,"Cannot calculate square root of negative number");
        // The ABI (Application Binary Interface) provides a standardized encoding format that enables different contracts (or external entities like frontends and wallets) to call each other’s functions
        // The ABI is a JSON-formatted description of a smart contract’s interface, generated by the Solidity compiler from the contract’s source code (.sol file).
        // The ABI is specifically designed for blockchain, which mainly works for interaction between contracts and front-end development.
        // It includes: function names, input parameter types, return types,function state mutability,events,constructor and so on.
        //The ABI defines how to encode function calls and decode responses, ensuring compatibility across tools (e.g., wallets, DApps, other contracts). Without the ABI, external entities cannot know the contract’s functions or how to format inputs.
        
        //abi.encodeWithSignature is a Solidity function that takes a function signature (as a string) and arguments, encoding them into a bytes array per the Ethereum ABI specification.
        // bytes memory data = abi.encodeWithSignature(string memory signature, ...args);
        //signature: A string like "functionName(type1,type2,...), e.g., "withdraw(uint256)".
        // args: The arguments to the function, matching the types in the signature.
        // Returns: A bytes array ready for low-level calls.Returned Data:First 4 bytes: Function selector for withdraw(uint256), e.g., 0x2e1a7d4d (from keccak256("withdraw(uint256)")[:4]).Next 32 bytes: The encoded uint256 argument 1 ether (1000000000000000000), padded to 32 bytes (e.g., 0x0000000000000000000000000000000000000000000000000de0b6b3a7640000).
        bytes memory data=abi.encodeWithSignature("squareRoot(int256)",number);
        // ".call(data) sends that data to the address stored in scientificCalculatorAddress"
        (bool success,bytes memory returnData)=scientificCalculatorAddress.call(data);
        require(success,"External call failed");
        uint256 result=abi.decode(returnData,(uint256));
        return result;

    }

}