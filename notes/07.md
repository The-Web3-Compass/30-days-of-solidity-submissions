üß† Core Solidity Concepts Illustrated
Concept	Definition	Example in Code
SPDX License Identifier	Declares the license type for open-source compliance.	//SPDX-License-Identifier: MIT
Pragma Directive	Specifies the compiler version. Prevents incompatibility errors.	pragma solidity ^0.8.0;
Contract	Like a class in OOP‚Äîencapsulates data (state variables) and behavior (functions).	contract SimpleIOU { ... }
State Variable	Stored permanently on the blockchain (in ‚Äústorage‚Äù).	address public owner;, mapping(...) balances;
Mapping	A hash table used for fast lookup between key-value pairs.	mapping(address => uint256) public balances;
Constructor	Runs once when the contract is deployed‚Äîused to initialize state.	constructor() { ... }
msg.sender	Built-in global variable: the address that called the function.	Used throughout.
Modifiers	Reusable access-control logic that wraps around functions.	modifier onlyOwner() and onlyRegistered()
require()	Validation‚Äîstops execution if condition fails, refunds gas.	require(msg.sender == owner, ...)
payable	Enables a function to receive ETH.	function depositIntoWallet() public payable
call() / transfer()	Methods for sending Ether. call is low-level, transfer is safer but limited.	transferEther() and transferEtherViaCall()
view function	Reads state but doesn‚Äôt modify it; no gas if called externally.	function checkBalance() public view ...
üîç Line-by-Line Breakdown
1Ô∏è‚É£ Header and Compiler
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


SPDX license declares that this contract uses the MIT license.

Pragma fixes the compiler version to 0.8.x ‚Äî important because Solidity syntax and safety rules evolve.

2Ô∏è‚É£ Define the Contract
contract SimpleIOU {


contract is like a class ‚Äî everything inside defines your decentralized app‚Äôs logic and data.

SimpleIOU manages a simple debt ledger between ‚Äúfriends.‚Äù

3Ô∏è‚É£ Owner Definition
address public owner;


address stores an Ethereum address (wallet or contract).

public automatically creates a getter.

The owner (creator) will have special permissions.

4Ô∏è‚É£ Registered Friends Data
mapping(address => bool) public registeredFriends;
address[] public friendList;


mapping allows O(1) lookup: is someone registered? true/false.

friendList stores all friend addresses (for enumeration).

5Ô∏è‚É£ Balances and Debts
mapping(address => uint256) public balances;
mapping(address => mapping(address => uint256)) public debts;


balances keeps track of each user‚Äôs internal wallet.

debts is a nested mapping:
debts[debtor][creditor] = amount
‚Üí it models who owes whom.

6Ô∏è‚É£ Constructor
constructor() {
    owner = msg.sender;
    registeredFriends[msg.sender] = true;
    friendList.push(msg.sender);
}


Runs once on deployment.

msg.sender is the deployer‚Äôs address ‚Üí becomes the owner.

Automatically registers the owner as the first ‚Äúfriend.‚Äù

7Ô∏è‚É£ Modifiers for Access Control
modifier onlyOwner() {
    require(msg.sender == owner, "Only owner can perform this action");
    _;
}


modifier adds pre-check logic before running the function.

_ = placeholder for the original function body.

Ensures only the owner can execute certain functions.

modifier onlyRegistered() {
    require(registeredFriends[msg.sender], "You are not registered");
    _;
}


Ensures only registered users can interact with sensitive functions.

8Ô∏è‚É£ Add a Friend
function addFriend(address _friend) public onlyOwner {
    require(_friend != address(0), "Invalid address");
    require(!registeredFriends[_friend], "Friend already registered");
    
    registeredFriends[_friend] = true;
    friendList.push(_friend);
}


onlyOwner ensures the owner controls who joins.

Validates:

_friend is not a null address.

Not already registered.

Adds to both mapping and list.

9Ô∏è‚É£ Deposit ETH
function depositIntoWallet() public payable onlyRegistered {
    require(msg.value > 0, "Must send ETH");
    balances[msg.sender] += msg.value;
}


payable allows receiving ETH.

ETH sent (msg.value) is credited to internal balance.

Example: like topping up an account.

üîü Record Debt
function recordDebt(address _debtor, uint256 _amount) public onlyRegistered {
    require(_debtor != address(0), "Invalid address");
    require(registeredFriends[_debtor], "Address not registered");
    require(_amount > 0, "Amount must be greater than 0");
    
    debts[_debtor][msg.sender] += _amount;
}


A registered user can declare that _debtor owes them _amount.

Only updates internal bookkeeping (no real transfer yet).

1Ô∏è‚É£1Ô∏è‚É£ Pay Debt Using Wallet Balance
function payFromWallet(address _creditor, uint256 _amount) public onlyRegistered {
    require(_creditor != address(0), "Invalid address");
    require(registeredFriends[_creditor], "Creditor not registered");
    require(_amount > 0, "Amount must be greater than 0");
    require(debts[msg.sender][_creditor] >= _amount, "Debt amount incorrect");
    require(balances[msg.sender] >= _amount, "Insufficient balance");
    
    balances[msg.sender] -= _amount;
    balances[_creditor] += _amount;
    debts[msg.sender][_creditor] -= _amount;
}


Transfers value within internal balances, not on-chain ETH transfer.

Keeps gas low, avoids external calls.

Adjusts both balances and debts atomically.

1Ô∏è‚É£2Ô∏è‚É£ Direct Transfer via transfer()
function transferEther(address payable _to, uint256 _amount) public onlyRegistered {
    require(_to != address(0), "Invalid address");
    require(registeredFriends[_to], "Recipient not registered");
    require(balances[msg.sender] >= _amount, "Insufficient balance");
    balances[msg.sender] -= _amount;
    _to.transfer(_amount);
    balances[_to] += _amount;
}


Uses Solidity‚Äôs built-in transfer(), which:

Automatically reverts on failure.

Forwards 2300 gas (safe from reentrancy).

Deducts sender‚Äôs balance and credits receiver.

1Ô∏è‚É£3Ô∏è‚É£ Transfer via call()
function transferEtherViaCall(address payable _to, uint256 _amount) public onlyRegistered {
    require(_to != address(0), "Invalid address");
    require(registeredFriends[_to], "Recipient not registered");
    require(balances[msg.sender] >= _amount, "Insufficient balance");
    
    balances[msg.sender] -= _amount;
    
    (bool success, ) = _to.call{value: _amount}("");
    balances[_to] += _amount;
    require(success, "Transfer failed");
}


Demonstrates low-level call method.

More flexible (forwards all gas), but less safe ‚Üí needs explicit require(success).

1Ô∏è‚É£4Ô∏è‚É£ Withdraw to Wallet
function withdraw(uint256 _amount) public onlyRegistered {
    require(balances[msg.sender] >= _amount, "Insufficient balance");
    
    balances[msg.sender] -= _amount;
    
    (bool success, ) = payable(msg.sender).call{value: _amount}("");
    require(success, "Withdrawal failed");
}


Converts internal credit back to ETH sent to the user.

Uses call instead of transfer to avoid gas limit issues.

1Ô∏è‚É£5Ô∏è‚É£ Check Balance
function checkBalance() public view onlyRegistered returns (uint256) {
    return balances[msg.sender];
}


view: reads blockchain data without changing it.

Simple getter for a user‚Äôs internal wallet.

üí° Why Write It This Way
Design Choice	Why
Access control via modifiers	Centralizes permission logic ‚Üí cleaner & safer.
Mappings over arrays for state lookup	Cheaper gas, O(1) lookup.
Use of require()	Enforces rules and ensures predictable reverts.
Internal balances	Allows accounting logic without immediate on-chain ETH transfers (faster + cheaper).
transfer() and call() examples	Demonstrates both ETH-sending methods and their trade-offs.
Explicit checks	Prevents reentrancy and invalid state updates.

‚úÖ In summary:
SimpleIOU is a mini accounting dApp that models how to:

Handle permissions and registration,

Accept and send ETH securely,

Track internal balances and debts,

Prevent unauthorized access and invalid states.